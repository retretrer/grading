<!--
This component describes a single test.

It creates a setInterval to run the test function as defined in the
grader.js file.

The test bubbles an 'test-passed' event to the <test-suite> when it passes.
-->

<template id="active-test">
  <style scoped>
    .correct {
      color: #060;
    }
    .correct::before {
      content: "✓ ";
    }
    .incorrect {
      color: #900;
    }
    .incorrect::before {
      content: "✗ ";
    }
    .test-desc {
      width: 100%;
    }
  </style>
  <div class="test-desc incorrect"></div>
</template>
<script>
  (function() {
    var importDoc = document.currentScript.ownerDocument;
    var proto = Object.create(HTMLElement.prototype);

    proto.createdCallback = function() {
      // I call them 'active-tests' because they run themselves
      var template = importDoc.querySelector('#active-test');
      var clone = document.importNode(template.content, true);
      var root = this.createShadowRoot();
      root.appendChild(clone);
    };

    proto.attachedCallback = function() {
      var testFunc = this.test.func;
      var testParams = this.test.params;
      var testDesc = this.test.desc;

      // Optional flags defined below!
      var noRepeat = this.test.noRepeat || false;
      var async = this.test.async || false;
      var showCurrent = this.test.showCurrent || false;

      var td = this.shadowRoot.querySelector('.test-desc');
      td.innerHTML = testDesc;

      if (showCurrent) td.insertAdjacentHTML('beforeend', '<br>&nbsp;&nbsp;&nbsp;&nbsp;Currently: pending');
      
      /*
      Thanks StackOverflow!
      http://stackoverflow.com/questions/359788/how-to-execute-a-javascript-function-when-i-have-its-name-as-a-string
      */
      function executeFunctionByName(functionName, context) {
        var args = [].slice.call(arguments).splice(2);
        var namespaces = functionName.split(".");
        var func = namespaces.pop();
        for(var i = 0; i < namespaces.length; i++) {
          context = context[namespaces[i]];
        }
        return context[func].apply(this, args);
      }

      function testHasPassed() {
        td.classList.toggle('incorrect');
        td.classList.toggle('correct');
        var passEvent = new CustomEvent('test-passed', {'detail': testDesc});
        td.dispatchEvent(passEvent);
        clearInterval(gradeRunner);
      }
      
      function renderCurrentValue(val) {
        // drops the pending placeholder from Currently: pending
        td.innerHTML = td.innerHTML.slice(0, td.innerHTML.length - 7);
        // adds the new value
        td.insertAdjacentHTML('beforeend', val);
      };
      
      function runAsyncTest(cb, params) {
        var responseDetails = {};
        var callback = {
          success: function(detail) {
            testHasPassed();
          },
          error: function(detail) {
            console.log("test failed");
            // nothing for now
          },
          update: function(detail) {
            // TODO: expand this logic to show other pieces of data.
            console.log("test update");
            if (showCurrent && responseDetails['bytes']) renderCurrentValue((responseDetails['bytes'] / 1000000).toString().slice(0,4) + "MB");
          }
        };

        var promise = new Promise(
            function(resolve, reject) {
              cb(params);
              document.querySelector('test-widget').addEventListener('page-bytes', function(e) {
                responseDetails = e.detail;
                if (responseDetails['passed']) {
                  resolve(responseDetails);
                } else if (!responseDetails['passed']) {
                  reject(e.detail);
                }
              })
            }).then(callback.success, callback.error).then(callback.update);
      }



      var testCorrect = false;
      var gradeRunner = setInterval(function() {
        // testCorrect = executeFunctionByName(testFunc, grader, testParams);
        // testCorrect = grader[testFunc](testParams);
        
        if (async) {
          runAsyncTest(grader[testFunc], testParams);
        } else if (!async) {
          try {
            testCorrect = grader[testFunc](testParams);
          } catch (e) {
            // TODO: make this more useful
            throw new Error("Test: " + testFunc + " failed to execute with args:" + testParams[0]);
          }
          if (testCorrect) testHasPassed();
        }
        if (noRepeat || async) clearInterval(gradeRunner);
      }, 1000)

    };

    document.registerElement('active-test', {prototype: proto});
  })();
</script>